## A. Printer ##

```
#include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double  pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 2e5 + 10, M = 2 * N;
 
void solve(){
    int n, k;
    cin >> n >> k;

    vector<vector<int>> a;
    for(int i = 0; i < n; i++){
        int t, l, w;
        cin >> t >> l >> w;
        a.push_back({t, l, w});
    }

    auto check = [&](ll mid) -> bool{
        ll t = k;

        for(int i = 0; i < n; i++){
            ll x = a[i][0], y = a[i][1], z = a[i][2];
            
            ll l = 0, r = (int)1e9 + 1;
            while(l < r){
                ll mmid = l + r >> 1;
                if(mmid * x + (mmid - 1) / y * z >= mid){
                    r = mmid;
                }
                else{
                    l = mmid + 1;
                }
            }
            if(l * x + (l - 1) / y * z > mid){
                l--;
            }
            t -= l;

            if(t <= 0){
                break;
            }
        }
        return t <= 0;
    };

    ll l = 0, r = INF; 
    while(l < r){
        ll mid = l + r >> 1;

        if(check(mid)){
            r = mid;
        }
        else{
            l = mid + 1;
        }
    }

    cout << l << "\n";
}   
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## C. Colorful Segments 2 ##

```
#include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double  pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 2e5 + 10, M = 2 * N;

template <typename T>
struct Fenwick{
    int n;
    vector<T> a;
    
    Fenwick(int n = 0){
        init(n);
    }
    
    void init(int len){
        n = len;
        a.assign(n + 1, T{});
    }

    int lowbit(int i){
        return i & -i;
    }
    
    void add(ll x, const T &v) {
        for(ll i = x; i <= n; i += lowbit(i)){
            a[i] += v;
        }
    }

    T query(ll x) {
        ll sum = 0;
        for(ll i = x; i; i -= lowbit(i)){
            sum += a[i];
        }
        return sum;
    }
    
    T range_query(int l, int r) {
        return query(r) - query(l);
    }

    int select(const T &k) {
        int x = 0;
        T cur{};
        for(int i = 1 << __lg(n); i; i /= 2){
            if(x + i <= n && cur + a[x + i - 1] <= k){
                x += i;
                cur = cur + a[x - 1];
            }
        }
        return x;
    }
};
 
void solve(){
    int n, k;
    cin >> n >> k;

    vector<vector<int>> a;
    vector<int> b;

    for(int i = 0; i < n; i++){
        int l, r;
        cin >> l >> r;
        a.push_back({l, r});
        b.push_back(l);
        b.push_back(r);
    }

    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());

    auto cmp = [&](const vector<int>& a, const vector<int>& b) -> bool{
        return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    };
    sort(a.begin(), a.end(), cmp);

    Fenwick<ll> fw(2 * n + 2);
    ll dp[n];

    for(int i = 0; i < a.size(); i++){
        int l = lower_bound(b.begin(), b.end(), a[i][0]) - b.begin() + 2;
        int r = lower_bound(b.begin(), b.end(), a[i][1]) - b.begin() + 2;

        ll ndp = chmax(0ll, k - (i - fw.query(l - 1)));
        dp[i] = (i ? dp[i - 1] : 1) * ndp % mod;
        fw.add(r, 1);
    }
    cout << dp[n - 1] << "\n";
}   
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## #include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 1e5 + 10, M = 2 * N;

void solve(){
    ll p, a, b;
    cin >> p >> a >> b;

    ll q, c, d;
    cin >> q >> c >> d;

    ll m, t;
    cin >> m >> t;


    if(m < p){
        cout << m << "\n";
        return;
    }

    if(b == 0 && d == 0){
        ll l = 0, r = (ll)1e9;
        while(l < r){
            ll mid = l + r >> 1;

            if(a * mid + c * mid > t || mid * p > m + mid * q){
                r = mid;
            }
            else{
                l = mid + 1;
            }
        }

        if(a * l + c * l > t || l * p > m + l * q){
            l--;
        }

        cout << m + l * q - l * p << "\n";
        return;
    }

    while(t){
        ll x = m / p;
        if(a * x + b + c * x + d > t){
            x = (t - b - d) / (a + c);
            if(x <= 0){
                break;
            }
            else{
                m -= x * p;
                t -= a * x + b + c * x + d;
            }
        }
        else{
            m -= x * p;
            t -= a * x + b + c * x + d;
        }

        if(x <= 0){
            break;
        }
        m += x * q;
    }
    cout << m << "\n";
}
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## F. Divide the Sequence  ##

```
#include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 1e5 + 10, M = 2 * N;

void solve(){
    int n;
    cin >> n;

    ll a[n + 1];
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }

    ll p[n + 1];
    p[0] = 0;

    for(int i = 1; i <= n; i++){
        p[i] = p[i - 1] + a[i];
    }
    sort(p + 1, p + n);

    ll acc = 0;
    for(int i = n; i >= 1; i--){
        acc += p[n - i];
        cout << (n - i + 1) * p[n] - acc << " \n"[i == 1]; 
    }
}
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## H. Stop the Castle  ##

```
#include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 1e5 + 10, M = 2 * N;

struct HopcroftKarp{
    int l, r;
    vector<vector<int>> g;
    vector<int> pl, pr, d;

    HopcroftKarp(int l, int r)
        : l(l), r(r), g(l),
          pl(l, -1), pr(r, -1), d(l, -1) {}

    void add(int u, int v){
        g[u].push_back(v);
    }

    bool bfs(){
        queue<int> q;
        d.assign(l, -1);

        for(int u = 0; u < l; ++u){
            if(pl[u] == -1){ 
                d[u] = 0;
                q.push(u);
            }
        }

        bool found = false;
        while(!q.empty()){
            int u = q.front(); q.pop();
            for(int v : g[u]){
                int u2 = pr[v];    

                if(u2 == -1){
                    found = true;
                }
                else if (d[u2] == -1) {
                    d[u2] = d[u] + 1;
                    q.push(u2);
                }
            }
        }
        return found;
    }

    bool dfs(int u){
        for(int v : g[u]){
            int u2 = pr[v];

            if(u2 == -1 || (d[u2] == d[u] + 1 && dfs(u2))){
                pl[u] = v;
                pr[v] = u;
                return true;
            }
        }

        d[u] = -1;
        return false;
    }

    int HK(){
        int ans = 0;
        while(bfs()){
            for(int u = 0; u < l; ++u){
                if(pl[u] == -1 && dfs(u)){
                    ++ans;
                }
            }
        }
        return ans;
    }
};

void solve(){
    int n;
    cin >> n;

    vector<vector<int>> a, r, c;
    for(int i = 0; i < n; i++){
        int x, y;
        cin >> x >> y;
        a.push_back({x, y});
    }

    int m;
    cin >> m;

    map<int, vector<int>> mpx, mpy;
    for(int i = 0; i < m; i++){
        int x, y;
        cin >> x >> y;
        
        mpx[y].push_back(x);
        mpy[x].push_back(y);
    }

    for(auto& [k, v] : mpx){
        sort(v.begin(), v.end());
    }
    for(auto& [k, v] : mpy){
        sort(v.begin(), v.end());
    }

    sort(a.begin(), a.end());
    for(int i = 1; i < n; i++){
        if(a[i][0] == a[i - 1][0]){
            if(abs(a[i - 1][1] - a[i][1]) == 1){
                cout << -1 << "\n";
                return;
            }

            int x = a[i][0];
            auto L = upper_bound(mpy[x].begin(), mpy[x].end(), a[i - 1][1]) - mpy[x].begin();
            auto R = lower_bound(mpy[x].begin(), mpy[x].end(), a[i][1]) - mpy[x].begin();

            if(L == R){
                r.push_back({a[i][0], a[i - 1][1], a[i][1]});
            }
        }
    }

    auto cmp = [&](const vector<int>& a, const vector<int>& b) -> bool{
        return a[1] == b[1] ? a[0] < b[0] : a[1] < b[1];
    };

    sort(a.begin(), a.end(), cmp);
    for(int i = 1; i < n; i++){
        if(a[i][1] == a[i - 1][1]){
            if(abs(a[i - 1][0] - a[i][0]) == 1){
                cout << -1 << "\n";
                return;
            }

            int y = a[i][1];
            auto L = upper_bound(mpx[y].begin(), mpx[y].end(), a[i - 1][0]) - mpx[y].begin();
            auto R = lower_bound(mpx[y].begin(), mpx[y].end(), a[i][0]) - mpx[y].begin();

            if(L == R){
                c.push_back({a[i][1], a[i - 1][0], a[i][0]});
            }
        }
    }

    HopcroftKarp hk(r.size(), c.size());

    for(int i = 0; i < c.size(); i++){
        int x = c[i][0], y1 = c[i][1], y2 = c[i][2];
        for(int j = 0; j < r.size(); j++){
            int y = r[j][0], x1 = r[j][1], x2 = r[j][2];

            if(x1 < x && x < x2 && y1 < y && y < y2){
                hk.add(j, i);
            }
        }
    }

    int M = hk.HK();
    cout << c.size() + r.size() - M << "\n";

    vector<int> v1(r.size()), v2(c.size());
    for(int i = 0; i < r.size(); i++){
        if(hk.pl[i] != -1){
            int u = hk.pl[i];
            cout << r[i][0] << " " << c[u][0] << "\n";
            v1[i] = v2[u] = 1;
        }
    }

    for(int i = 0; i < r.size(); i++){
        if(!v1[i]){
            cout << r[i][0] << " " << r[i][1] + 1 << "\n";
        }
    }
    for(int i = 0; i < c.size(); i++){
        if(!v2[i]){
            cout << c[i][1] + 1 << " " << c[i][0] << "\n";
        }
    }
}
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## I. Left Shifting  ##

```
#include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double  pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 2e5 + 10, M = 2 * N;
 
void solve(){
    string s;
    cin >> s;

    if(s[0] == s.back()){
        cout << 0 << "\n";
    }
    else{
        for(int i = 0; i < s.size() - 1; i++){
            if(s[i] == s[i + 1]){
                cout << i + 1 << "\n";
                return;
            }
        }
        cout << -1 << "\n";
    }
}   
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## #include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 1e5 + 10, M = 2 * N;

struct DSU{
    vector<int> node, size;
 
    DSU(){}
    DSU(int n){
        init(n);
    }
 
    void init(int n){
        node.resize(n);
        size.resize(n);
 
        for(int i = 0; i < n; i++){
            node[i] = i;
            size[i] = 1;
        }
    }
 
    int find(int x){
        return x == node[x] ? x : node[x] = find(node[x]);
    }
 
    void erase(int x){
        size[find(x)] -= 1;
        node[x] = x;
    }
 
    void relocate(int x, int y){ //can't be root
        int dx = find(x), dy = find(y);
        if(dx == dy){
            return;
        }
        node[x] = dy;
        size[dx] -= 1;
        size[dy] += 1;
    }
 
    int set(int x, int y){
        return find(x) == find(y);
    }
 
    int merge(int x, int y){
        x = find(x);
        y = find(y);
        if(x == y){
            return 0;
        }
 
        size[x] += size[y];
        node[y] = x;
        return 1;
    }
 
    int heuristic_merge(int x, int y){ 
        x = find(x);
        y = find(y);
        if(size[x] < size[y]){
            swap(x, y);
        }
        return merge(x, y);
    }
 
    int get(int x){
        return size[find(x)];
    }
};

void solve(){
    int n;
    cin >> n;

    ll a[n], b[n][n], c[n];
    for(int i = 0; i < n; i++){
        cin >> a[i];
        c[i] = (int)1e9;
    }

    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            cin >> b[i][j];
            c[i] = chmin(c[i], b[i][j]);
        }
    }

    DSU dsu(n + 1);
    vector<vector<ll>> e;
    ll ans = 0;

    for(int i = 0; i < n; i++){
        if(a[i] > 1){
            ans += (a[i] - 1) * c[i];
        }
        for(int j = 0; j < n; j++){
            e.push_back({b[i][j], i, j});
        }
    }

    sort(e.begin(), e.end());
    for(int i = 0; i < e.size(); i++){
        int u = e[i][1], v = e[i][2], w = e[i][0];
        if(!dsu.set(u, v)){
            dsu.heuristic_merge(u, v);
            ans += w;
        }
    }

    cout << ans << "\n";
}   
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## K. Matrix ##

```
#include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double  pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 2e5 + 10, M = 2 * N;
 
void solve(){
    int n;
    cin >> n;

    cout << "Yes" << "\n";
    int a[n][n];

    a[0][0] = 1, a[0][1] = 2;
    a[1][0] = 3, a[1][1] = 4;

    int r = 2, c = 2, id = 5;
    for(int i = n - 2; i > 0; i--){
        for(int j = 0; j < c; j++){
            a[j][c] = id;
        }
        ++id;
        for(int j = 0; j < r + 1; j++){
            a[r][j] = id;
        }
        ++id, ++r, ++c;
    }

    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            cout << a[i][j] << " \n"[j == n - 1];
        }
    }
}   
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    // cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```

## M. Palindromic Polygon ##

```
#include <bits/stdc++.h>
using namespace std;

using ll  = long long;
using ld  = long double;
using i128 = __int128_t;

const double pi  = 3.14159265358979323846;
const int mod = 998244353;
const ll INF = 1e18;

template <typename T>
T chmax(T a, T b){
    return a > b ? a : b;
} 

template <typename T>
T chmin(T a, T b){
    return a > b ? b : a;
}

const int N = 1e5 + 10, M = 2 * N;

template<typename T>
struct Point{
    T x, y;
    ld eps;

    Point() : x(0), y(0), eps(1e-9) {}
    Point(T x, T y) : x(x), y(y), eps(1e-9) {}

    void set_eps(T eps){
        this->eps = eps;
    }

    Point operator+ (const Point& b){
        return Point(x + b.x, y + b.y);
    }

    Point operator- (const Point& b){
        return Point(x - b.x, y - b.y);
    }

    Point operator- (){
        return Point(-x, -y);
    }

    Point operator* (T t) const{
        return Point(x * t, y * t);
    }

    Point operator/ (T t) const{
        return Point(x / t, y / t);
    }

    Point &operator+=(Point p) &{
        x += p.x;
        y += p.y;
        return *this;
    }

    Point &operator-=(Point p) &{
        x -= p.x;
        y -= p.y;
        return *this;
    }

    Point &operator*=(T v) &{
        x *= v;
        y *= v;
        return *this;
    }

    Point &operator/=(T v) &{
        x /= v;
        y /= v;
        return *this;
    }

    Point &operator=(const Point& b) &{
        x = b.x;
        y = b.y;
        return *this;
    }

    friend Point operator+ (const Point& a, const Point& b){
        return {a.x + b.x, a.y + b.y};
    }

    friend Point operator- (const Point& a, const Point& b){
        return {a.x - b.x, a.y - b.y};
    }

    friend bool operator==(Point a, Point b){
        return a.x == b.x && a.y == b.y;
    }

    int sign(T x){
        if(fabs(x) < eps){
            return 0;
        }
        if(x < 0){
            return -1;
        }
        return 1;
    }

    bool cmp(T x, T y){
        if(fabs(x - y) > eps){
            return 0;
        }
        return 1;
    }

    bool cmp(const Point& a, const Point& b){
        return cmp(a.x, b.x) && cmp(a.y, b.y);
    }

    T dot(const Point& a, const Point& b){
        return a.x * b.x + a.y * b.y;
    }

    T square(Point a){
        return dot(a, a);
    }

    T cross(const Point& a, const Point& b){
        return a.x * b.y - a.y * b.x;
    }

    T cross(const Point& a, const Point& b, const Point& p){
        return (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
    }

    T get_len(const Point& a){
        return sqrt(dot(a, a));
    }

    T get_angle(const Point& a, const Point& b){
        return acos(dot(a, b) / get_len(a) / get_len(b));
    }

    T area(const Point& a, const Point& b, const Point& c){
        return cross(b - a, c - a);
    }

    Point rotate(const Point& a, T angle){ //两个点就 b - a (b按a转)
        T dx = a.x * cos(angle) + a.y * sin(angle); 
        T dy = -a.x * sin(angle) + a.y * cos(angle);
        return Point(dx, dy);
    }

    Point intersect(const Point& p, const Point& v, const Point& q, const Point& w){
        Point u = p - q;
        T t = cross(w, u) / cross(v, w);
        return p + v * t;
    }

    T point_dist(const Point& a, const Point& b){
        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
    }

    T line_dist(const Point& a, const Point& b, const Point& p){
        Point u = b - a, v = p - a;
        return fabs(cross(u, v)) / get_len(u);
    }

    T get_slope(const Point& a, const Point& b){
        if(b.y == a.y) return INF;
        if(b.x == a.x) return 0;
        return (b.y - a.y) / (b.x - a.x);
    }

    T circle_intersect(const Point& p1, const Point& p2, const T r1, const T r2){
        ld d = sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));

        if(d > r1 + r2 || d + chmin(r1, r2) <= chmax(r1, r2)){
            return 0;
        }
        else if(d == r1 + r2){
            return 1;
        }
        else{
            return 2;
        }
    }

    T seg_dist(const Point& a, const Point& b, const Point& p){
        if(a == b){
            return get_len(p - a);
        }
        Point u = b - a, v = p - a, w = p - b;

        if(sign(dot(u, v)) < 0){
            return get_len(v);
        }
        if(sign(dot(u, w)) > 0){
            return get_len(w);
        }
        return line_dist(a, b, p);
    }

    Point projection(const Point& a, const Point& b, const Point& p){
        Point v = b - a;
        return a + v * dot(v, p - a) / dot(v, v);
    }

    bool on_segment(const Point& a, const Point& b, const Point& p){
        bool u = sign(cross(p - a, p - b)) == 0;
        bool v = sign(dot(p - a, p - b)) <= 0;
        return u && v;
    }

    bool seg_intersection(const Point& a1, const Point& a2, const Point& b1, const Point& b2){
        T c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1);
        T c3 = cross(b2 - b1, a2 - b1), c4 = cross(b2 - b1, a1 - b1);
        return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0;
    }
};

ll dp[1001][1001], ndp[1001][1001];
int a[1001], dl[501], dr[501];
Point<ll> p[1001];

void solve(){
    int n;
    cin >> n;

    vector<int> b;
    for(int i = 0; i < n; i++){
        cin >> a[i];
        a[i + n] = a[i];

        b.push_back(a[i]); 
    }

    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());

    for(int i = 0; i < n; i++){
        int x, y;
        cin >> x >> y;
        p[i] = p[i + n] = Point<ll>(x, y);
    }

    Point<ll> pt;
    
    int m = n * 2;
    for(int i = 0; i < m; i++){
        for(int j = i + 1; j < chmin(m, i + n); j++){
            ndp[i][j] = pt.cross(p[i], p[j]);
            ndp[j][i] = -ndp[i][j];
        }
    }

    for(int i = 0; i < m; i++){
        a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();
        for(int j = 0; j < m; j++){
            dp[i][j] = 0;
        }
    }

    for(int len = 1; len < n; len++){
        for(int l = 0; l + len < m; l++){
            int r = l + len;
            if(a[l] == a[r]){
                if(r - l >= 3){
                    dp[l][r] = chmax(dp[l][r], dp[l + 1][r]);
                    dp[l][r] = chmax(dp[l][r], dp[l][r - 1]);

                    for(int k = l + 1; k < r; k++){
                        dl[a[k]] = dr[a[k]] = -1;
                    }
                    for(int k = l + 1; k < r; k++){
                        if(dl[a[k]] == -1){
                            dl[a[k]] = k;
                        }
                        dr[a[k]] = k;
                    }

                    for(int k = l + 1; k < r; k++){
                        if(dl[a[k]] != -1){
                            int L = dl[a[k]];
                            dp[l][r] = chmax(dp[l][r], dp[L][k] - ndp[k][L] + ndp[l][L] + ndp[k][r] + ndp[r][l]);
                        }
                        if(dr[a[k]] != -1){
                            int R = dr[a[k]];
                            dp[l][r] = chmax(dp[l][r], dp[k][R] - ndp[R][k] + ndp[l][k] + ndp[R][r] + ndp[r][l]);
                        }
                    }
                }  
                else{
                    dp[l][r] = chmax(dp[l][r], ndp[r][l] + ndp[l][l + 1] + ndp[l + 1][r]);
                }
            }
            else{
                dp[l][r] = chmax(dp[l + 1][r], dp[l][r - 1]);
            }
        }
    }

    ll ans = 0;
    for(int i = 0; i + n - 1 < m; i++){
        ans = chmax(ans, dp[i][i + n - 1]);
    }
    cout << ans << "\n";
}
    
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t = 1;
    cin >> t;

    while(t--){
        solve();
    }
    return 0;
}
```
